// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import frc.robot.Constants;
import frc.robot.Constants.ChassisConst;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.util.sendable.SendableRegistry;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.Faults;
import com.ctre.phoenix.sensors.CANCoderConfiguration;
import com.ctre.phoenix.sensors.CANCoderFaults;
import com.ctre.phoenix.sensors.CANCoderStatusFrame;
import com.ctre.phoenix.sensors.CANCoderStickyFaults;
import com.ctre.phoenix.sensors.SensorInitializationStrategy;
import com.ctre.phoenix.sensors.SensorTimeBase;
import com.ctre.phoenix.sensors.AbsoluteSensorRange;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.sensors.CANCoder;
import com.revrobotics.CANSparkMax.IdleMode;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Chassis extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private CANSparkMax leftFront;
private CANSparkMax leftFollower;
private MotorControllerGroup leftMotorGroup;
private CANSparkMax rightFront;
private CANSparkMax rightFollower;
private MotorControllerGroup rightMotorGroup;
private DifferentialDrive diffDrive;
private CANCoder leftCANCoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Timer m_timer=new Timer();
    double rtime=0;
    boolean slowing=false;
    double speed=0.0;

    // Faults _faults_L;
    // Faults _faults_R;
    
    /**
    *
    */
    public Chassis() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFront = new CANSparkMax(1, MotorType.kBrushed);
 
 leftFront.restoreFactoryDefaults();  
leftFront.setInverted(false);
leftFront.setIdleMode(IdleMode.kCoast);
  

leftFollower = new CANSparkMax(2, MotorType.kBrushed);
 
 leftFollower.restoreFactoryDefaults();  
leftFollower.setInverted(false);
leftFollower.setIdleMode(IdleMode.kCoast);
  

leftMotorGroup = new MotorControllerGroup(leftFront, leftFollower  );
 addChild("leftMotorGroup",leftMotorGroup);
 

rightFront = new CANSparkMax(3, MotorType.kBrushed);
 
 rightFront.restoreFactoryDefaults();  
rightFront.setInverted(false);
rightFront.setIdleMode(IdleMode.kCoast);
  

rightFollower = new CANSparkMax(4, MotorType.kBrushed);
 
 rightFollower.restoreFactoryDefaults();  
rightFollower.setInverted(false);
rightFollower.setIdleMode(IdleMode.kCoast);
  

rightMotorGroup = new MotorControllerGroup(rightFront, rightFollower  );
 addChild("rightMotorGroup",rightMotorGroup);
 

diffDrive = new DifferentialDrive(leftMotorGroup, rightMotorGroup);
 addChild("DiffDrive",diffDrive);
 diffDrive.setSafetyEnabled(true);
diffDrive.setExpiration(0.1);
diffDrive.setMaxOutput(0.8);


leftCANCoder = new CANCoder(5);
 
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    //rightMotorGroup.setInverted(true); //zk added 2022, but need to check our robot physically.
     
    /* set up followers */
        leftFollower.follow(leftFront);
        rightFollower.follow(rightFront);   
    
        
   /* adjust sensor phase so sensor moves
    * positive when Talon LEDs are green */
        //leftFront.setSensorPhase(true);
        //rightFront.setSensorPhase(true);      
         
        //leftCANCoder.setDistancePerPulse(ChassisConst.INCHES_PER_PULSE);
        
        /////////////////////////////////////////////////////////////////////////////////////////////////////////
        CANCoderConfiguration left_cancoder_config = new CANCoderConfiguration();
       // CANCoderConfiguration right_cancoder_config = new CANCoderConfiguration();
        // 1 ----- set units of the CANCoder to radians, with velocity being radians per second
        //CanCoder
        // _canCoder.velocityMeasurementPeriod = SensorVelocityMeasPeriod.Period_25Ms;
        // _canCoder.velocityMeasurementWindow = 64;
        // _canCoder.absoluteSensorRange = AbsoluteSensorRange.Signed_PlusMinus180;
        // _canCoder.magnetOffsetDegrees = 12.45;
        // _canCoder.sensorDirection = true;
        // _canCoder.initializationStrategy = SensorInitializationStrategy.BootToAbsolutePosition;
        // _canCoder.sensorCoefficient = 0.57;
        // _canCoder.unitString = "Birds!";
        // _canCoder.sensorTimeBase = SensorTimeBase.PerMinute;
        
        left_cancoder_config.sensorCoefficient = 0.08789062;  //2 * Math.PI / 4096.0;
        left_cancoder_config.unitString = "deg"; //"rad";
        left_cancoder_config.sensorTimeBase = SensorTimeBase.PerSecond;
        
           
        left_cancoder_config.absoluteSensorRange = AbsoluteSensorRange.Signed_PlusMinus180;
        left_cancoder_config.sensorDirection = false;
        left_cancoder_config.initializationStrategy = SensorInitializationStrategy.BootToZero; 


        leftCANCoder.configFactoryDefault();
        leftCANCoder.configAllSettings(left_cancoder_config);

        System.out.printf("leftCANCoder AbsPosition:",leftCANCoder.getAbsolutePosition(), "\n"); // prints the position of the CANCoder
        System.out.printf("leftCANCoder Velocity:",leftCANCoder.getVelocity(), "\n");  // prints the velocity recorded by the CANCoder

        
        ErrorCode left_error = leftCANCoder.getLastError(); // gets the last error generated by the CANCoder
        CANCoderFaults left_faults = new CANCoderFaults();
        ErrorCode left_faultsError = leftCANCoder.getFaults(left_faults); // fills faults with the current CANCoder faults; returns the last error generated
        CANCoderStickyFaults stickyFaults = new CANCoderStickyFaults();
        leftCANCoder.getStickyFaults(stickyFaults);
        
        leftCANCoder.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms
        leftCANCoder.getAllConfigs(left_cancoder_config);
        System.out.printf(left_cancoder_config.toString("_left_canCoder"));
        //Rotation2d.fromDegrees(leftCANCoder.getAbsolutePosition()).getDegrees();
        //double absolutePosition = Conversions.degreesToFalcon(getCanCoder().getDegrees() - angleOffset, Constants.Swerve.angleGearRatio);


            
        // 2 ----- set units of the CANCoder to radians, with velocity being radians per second
        // right_cancoder_config.sensorCoefficient = 2 * Math.PI / 4096.0;
        // right_cancoder_config.unitString = "rad";
        // right_cancoder_config.sensorTimeBase = SensorTimeBase.PerSecond;

        //     /* Swerve CANCoder Configuration */
        // right_cancoder_config.absoluteSensorRange = AbsoluteSensorRange.Unsigned_0_to_360;
        // right_cancoder_config.sensorDirection = false;
        // right_cancoder_config.initializationStrategy = SensorInitializationStrategy.BootToAbsolutePosition;

        // rightCANCoder.configFactoryDefault();
        // rightCANCoder.configAllSettings(right_cancoder_config);

        // System.out.printf("rightCANCoder AbsPosition:",rightCANCoder.getAbsolutePosition(), "\n"); // prints the position of the CANCoder
        // System.out.printf("rightCANCoder Velocity:",rightCANCoder.getVelocity(), "\n");  // prints the velocity recorded by the CANCoder


        // ErrorCode right_error = rightCANCoder.getLastError(); // gets the last error generated by the CANCoder
        // CANCoderFaults right_faults = new CANCoderFaults();;
        // ErrorCode right_faultsError = rightCANCoder.getFaults(right_faults); // fills faults with the current CANCoder faults; returns the last error generated

        // rightCANCoder.setStatusFramePeriod(CANCoderStatusFrame.SensorData, 10); // changes the period of the sensor data frame to 10ms
          
        
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        m_timer.reset(); 
        m_timer.start();
  
        
    }

    // public void run() {
    //     /* Report position, absolute position, velocity, battery voltage */
    //     double posValue = _CANCoder.getPosition();
    //     String posUnits = _CANCoder.getLastUnitString();
    //     double posTstmp = _CANCoder.getLastTimestamp();
        
    //     double absValue = _CANCoder.getAbsolutePosition();
    //     String absUnits = _CANCoder.getLastUnitString();
    //     double absTstmp = _CANCoder.getLastTimestamp();
        
    //     double velValue = _CANCoder.getVelocity();
    //     String velUnits = _CANCoder.getLastUnitString();
    //     double velTstmp = _CANCoder.getLastTimestamp();
        
    //     double batValue = _CANCoder.getBusVoltage();
    //     String batUnits = _CANCoder.getLastUnitString();
    //     double batTstmp = _CANCoder.getLastTimestamp();
  
    //     /* Report miscellaneous attributes about the CANCoder */
    //     MagnetFieldStrength magnetStrength = _CANCoder.getMagnetFieldStrength();
    //     String magnetStrengthUnits = _CANCoder.getLastUnitString();
    //     double magnetStrengthTstmp = _CANCoder.getLastTimestamp();
  
    //     System.out.print("Position: ");
    //     printValue(posValue, posUnits, posTstmp);
    //     System.out.print("Abs Pos : ");
    //     printValue(absValue, absUnits, absTstmp);
    //     System.out.print("Velocity: ");
    //     printValue(velValue, velUnits, velTstmp);
    //     System.out.print("Battery : ");
    //     printValue(batValue, batUnits, batTstmp);
    //     System.out.print("Strength: ");
    //     printValue(magnetStrength, magnetStrengthUnits, magnetStrengthTstmp);
  
    //     /* Fault reporting */
    //     CANCoderFaults faults = new CANCoderFaults();
    //     _CANCoder.getFaults(faults);
    //     CANCoderStickyFaults stickyFaults = new CANCoderStickyFaults();
    //     _CANCoder.getStickyFaults(stickyFaults);
  
    //     System.out.println("Faults:");
    //     printFaults(faults);
    //     System.out.println("Sticky Faults:");
    //     printFaults(stickyFaults);
  
    //     System.out.println();
    //     System.out.println();
    //   }

   

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
         /* drive motor at least 25%, Talons will auto-detect if sensor is out of phase */
         SendableRegistry.add(diffDrive, "my DiffDrive");

        // leftFront.getFaults(_faults_L);
        // rightFront.getFaults(_faults_R);
        
        // if (_faults_L.SensorOutOfPhase) {System.out.println(" L sensor is out of phase");}
        // if (_faults_R.SensorOutOfPhase) {System.out.println(" R sensor is out of phase");}    
        
        /* print to console */
        // if ( work.str().find(filter) == std::string::npos ) 
        //     std::cout << work.str() << std::endl;              
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    /*
    KZ 2022-01-16: add a public method to access private variable diffDrive */
    public void ArcadeDrive(double xSpeed, double zRotation, boolean squareInputs){
        
        /* deadband gamepad 10%*/
        // if (Math.abs(forw) < 0.10)
        //     forw = 0;
        // if (Math.abs(turn) < 0.10)
        //     turn = 0;
        diffDrive.setDeadband(0.01); /* deadband gamepad 1%*/
        diffDrive.arcadeDrive(xSpeed, zRotation, squareInputs);          
    }

    //KZ added 2022-01-19
    public void encoderReset() {
        //chassis_quadEncoder1.reset();
        leftCANCoder.setPosition(0);
        //rightCANCoder.setPosition(0);
        

    }

    //KZ added 2022-01-19
    public void stop() {
        ArcadeDrive(0.0, 0.0, false);
    }

    // public double getDistance() {        
    //     //return chassis_quadEncoder1.getDistance();
    //     return leftCANCoder.getAbsolutePosition()*ChassisConst.CANCODER_INCHES_PER_DEGREE;  
    
    // }

    public double GetLeftSelectedSensorVelocity() {
        //return leftFront.getSelectedSensorVelocity(0);
        return leftCANCoder.getVelocity();
        
    }

    // public double GetRightSelectedSensorVelocity() {
    //     //return rightFront.getSelectedSensorVelocity(0);
    //     return rightCANCoder.getVelocity();
       
    // }


    // public void moveForward(double dist) {
    //     double cpos= ChassisConst.CANCODER_DISTANCE_PER_DEGREE * leftCANCoder.getVelocity() * m_timer.get();
    //     //double cpos= ChassisConst.CANCODER_DISTANCE_PER_DEGREE * leftCANCoder.getAbsolutePosition();          
     
    //     /* [1] starting phase:
    //            rtime = get() current time (double) */
    //     if ( cpos < 0.01) {
    //         rtime=m_timer.get(); 
    //         slowing=false;
    //     }

    //      /* [2] ending phase:
    //             Acheive 85% distance && slowing = false 
    //             rtime = get() current time (double) */       
    //     double rpos=cpos/dist;
    //     if ( rpos > 0.85 && !slowing ) { //KZ2022:           
    //         rtime=m_timer.get(); 
    //         slowing=true;
    //     }

    //      /* [3] middle phase:
    //             dtime = current time (m_timer.get()) - recent time (rtime) */                   
    //     double dtime=m_timer.get();
    //     // if slowing is false
    //     if ( !slowing ) {
    //         if (dtime < 0.1 ) speed=0.1;
    //         if (speed < 0.6 ) speed=speed+(dtime/20.0);

    //     } // if slowing is true
    //     else if ( slowing ) {
    //              if ( dtime < 0.1 ) speed=0.3;
    //              else if ( dtime < 0.5 ) speed=0.2;
    //                    else if ( dtime < 1.0 ) speed=0.1;          
    //     }
    //     /////////////////////////////////////////////////////////////////////
    //     /* KZ will dooule check what is the meaning of this segment of code */

    //     //printf
    //     //std::cout << "T: " << m_timer.Get().to<double>() << " ME: " << cpos << " S: " << speed << " Delta: " << dtime << " Ph: " << phase << std::endl;
    //     //System.out.printf("T: ", m_timer.get(), " ME: ", cpos, " S: ", speed, " Delta: ", dtime);            

    //     if (cpos < dist) diffDrive.arcadeDrive(speed, 0, false); // move straigt line!
    //     else {
    //         //phase++;
    //         encoderReset();          
    //     }
    // }

    public void moveForward(boolean isMoving) {
        
        rtime=m_timer.get(); 

        if (isMoving && rtime<= Constants.AUTO_TIME) ArcadeDrive(0.3, 0, false); // we can use different time to control different speed but now let's set it to 0.3
        else stop();

    }

    public void moveBackward(boolean isMoving) {
        
     
        if (isMoving==true) ArcadeDrive(-0.3, 0, false);
        else if (isMoving==false) stop();
        
    }

    public void setMotors(double leftSpeed, double rightSpeed) {
        leftMotorGroup.set(leftSpeed);
        rightMotorGroup.set(-rightSpeed);

    }


  
}

